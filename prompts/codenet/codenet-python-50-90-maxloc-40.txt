# slower version:

N = int(input())
a = [int(input()) for _ in range(N)]

cnt, i = 0, 0
for j in range(10 ** 6):
    cnt += 1
    if a[i] == 2:
        print(cnt)
        #break
        quit()
    else:
        i = a[i] - 1
print(-1)

# optimized version of the same code:

N = int(input())
a = [int(input()) for _ in range(N)]

cnt, i = 0, 0
for j in range(len(a)):
    cnt += 1
    if a[i] == 2:
        print(cnt)
        #break
        quit()
    else:
        i = a[i] - 1
print(-1)




# slower version:

A = [list(map(int,input().split())) for _ in range(3)]
N = int(input())
B = [int(input()) for _ in range(N)]
for i in range(3):
    bng = 1
    for j in range(3):
        if A[i][j] in B:
            continue
        else:
            bng = 0
            break
    if bng ==1:break
if bng==1:
    print('Yes')
else:
    for j in range(3):
        bng = 1
        for i in range(3):
            if A[i][j] in B:
                continue
            else:
                bng = 0
                break
        if bng==1:break
    if bng==1:
        print('Yes')
    else:
        if A[0][0] in B and A[1][1] in B and A[2][2] in B:
            print('Yes')
        elif A[0][2] in B and A[1][1] in B and A[2][0] in B:
            print('Yes')
        else:
            print('No')

# optimized version of the same code:

A = [list(map(int,input().split())) for _ in range(3)]
N = int(input())
B = [[0 for _ in range(3)] for _ in range(3)]
for _ in range(N):
    b = int(input())
    for i in range(3):
        for j in range(3):
            if A[i][j]==b:
                B[i][j] = 1
flag = 0
for i in range(3):
    if sum(B[i])==3:
        flag = 1
        break
for j in range(3):
    cnt = 0
    for i in range(3):
        cnt += B[i][j]
    if cnt==3:
        flag = 1
        break
if B[0][0]+B[1][1]+B[2][2]==3:
    flag = 1
if B[2][0]+B[1][1]+B[0][2]==3:
    flag = 1
if flag==1:
    print('Yes')
else:
    print('No')




# slower version:

N = int(input())
A = list(map(int, input().split()))
mod = int(1e+9 + 7)
L = A[0]
p = mod - 2
X = []
while p != 0:
  X = [p%2] + X[:]
  p //= 2

def inved(x):
  y = 1
  for i in range(len(X)):
    if X[i] == 1:
      y *= x
      y %= mod
    if i != len(X) - 1:
      y *= y
      y %= mod
  return y

for i in range(N-1):
  a, b = L, A[i+1]
  while b != 0:
    a, b = b, a % b
  b = A[i+1] // a
  L = b * L
S = 0
for i in range(N):
  S += (L * inved(A[i])) % mod
  S %= mod
print(S)



# optimized version of the same code:

N = int(input())
A = list(map(int, input().split()))
mod = int(1e+9 + 7)
L = A[0]
def inved(a):
  x, y, u, v, k, l = 1, 0, 0, 1, a, mod
  while l != 0:
    x, y, u, v = u, v, x - u * (k // l), y - v * (k // l)
    k, l = l, k % l
  return x % mod
for i in range(N-1):
  a, b = L, A[i+1]
  while b != 0:
    a, b = b, a % b
  b = A[i+1] // a
  L = b * L
L %= mod
S = 0
for i in range(N):
  S += inved(A[i])
  S %= mod
S *= L
S %= mod
print(S)




# slower version:

class BIT:
    def __init__(self,n):
        self.size=n
        self.tree=[0]*-~n
    def sum(self,i):
        s=0
        while i:
            s+=self.tree[i]
            i-=i&-i
        return s
    def add(self,i,x):
        while i<=self.size:
            self.tree[i]+=x
            i+=i&-i
n,k,*a=map(int,open(0).read().split())
a=[t-k for t in a]
for i in range(1,n):
    a[i]+=a[i-1]
d={}
for i,v in enumerate(sorted(set(a+[0])),1):
    d[v]=i
for i in range(n):
    a[i]=d[a[i]]
b=BIT(max(a))
b.add(d[0],1)
c=0
for i,p in enumerate(a):
    c+=b.sum(p)
    b.add(p,1)
print(c)

# optimized version of the same code:

class BIT:
    def __init__(self,n):
        self.size=n
        self.tree=[0]*-~n
    def sum(self,i):
        s=0
        while i:
            s+=self.tree[i]
            i-=i&-i
        return s
    def add(self,i,x):
        while i<=self.size:
            self.tree[i]+=x
            i+=i&-i
n,k,*a=map(int,open(0).read().split())
a=[t-k for t in a]
for i in range(1,n):
    a[i]+=a[i-1]
d={}
for i,v in enumerate(sorted(set(a+[0])),1):
    d[v]=i
for i in range(n):
    a[i]=d[a[i]]
b=BIT(max(a))
b.add(d[0],1)
c=0
for p in a:
    c+=b.sum(p)
    b.add(p,1)
print(c)




# slower version:

S = input()
ans = 0
mods = [0] * 2019
mods[0] = 1
curr = 0
x = 1
for d in S:
    curr = curr * 10 + int(d)
    ans += mods[curr * x % 2019]
    mods[curr * x % 2019] += 1
    x = x * 202 % 2019
    curr %= 2019
print(ans)


# optimized version of the same code:

S = input()
ans = 0
mods = [0] * 2019
mods[0] = 1
curr = 0
x = 1
for d in reversed(S):
    curr = (curr + int(d) * x) % 2019
    ans += mods[curr % 2019]
    mods[curr % 2019] += 1
    x = x * 10 % 2019
print(ans)





# slower version:

import numpy as np

h, w = map(int, input().split())
al = list(list(input()) for _ in range(h))
al_n = np.array(al)
row = [0]*w
col = [0]*h
for i in range(h):
    for j in range(w):
        if al_n[i][j] == '.':
            row[j] += 1
            col[i] += 1
row_ = []
col_ = []
for i in range(w):
    if row[i] == h:
        row_.append(i)

for j in range(h):
    if col[j] == w:
        col_.append(j)

if len(col_) > 0:
    al_n = np.delete(al_n, col_, axis=0)

if len(row_) > 0:
    al_n = np.delete(al_n, row_, axis=1)

for a in al_n:
    print(*a, sep='')

# optimized version of the same code:

h, w = map(int, input().split())
al = list(list(input()) for _ in range(h))
row = [0]*w
col = [0]*h

for i in range(h):
    for j in range(w):
        if al[i][j] == '#':
            col[i] += 1
            row[j] += 1
ans = []
w_len = len(row) - row.count(0)
for i in range(h):
    tmp = ''
    if col[i] != 0:
        for j in range(w):
            if row[j] != 0:
                tmp += al[i][j]
        ans.append(tmp)

for a in ans:
    print(*a, sep='')




# slower version:

S=input()
stack=[]
count=0
for s in S:
    if not stack:
        stack.append(s)
    elif stack[-1]!=s:
        stack.pop()
        count+=2
    else:
        stack.append(s)
print(count)

# optimized version of the same code:

S=input()
A=S.count('0')
B=S.count('1')
C=min(A,B)
print(C*2)




# slower version:

import collections
s = input()
t = input()
s = collections.Counter(s)
t = collections.Counter(t)
if sorted(s.values()) == sorted(t.values()):
  print('Yes')
else:
  print('No')


# optimized version of the same code:

s = input()
t = input()

dict_st = {}
dict_ts = {}

for x, y in zip(s, t):
    if x not in dict_st:
        dict_st[x] = y 
    else:
        if dict_st[x] != y:
            print('No')
            break

    if y not in dict_ts:
        dict_ts[y]=x
    else:
        if dict_ts[y]!=x:
            print('No')
            break
else:
    print('Yes')




