# slower version:

X = list(map(int,input().split()))
c=100000
b=200000
a=300000
X.sort()
ans=0
cnt=0
for i in X:
    if i==1:
        ans+=a
        cnt+=1
    elif i==2:
        ans+=b
    elif i==3:
        ans+=c
if cnt==2:
    ans += 400000
print(ans)

# optimized version of the same code:

# coding: utf-8

x, y = map(int,input().split())

l1 = [1,2,3]
l2 = [300000,200000,100000]

ans = 0
if x in l1:
    ans += l2[l1.index(x)]
    
if y in l1:
    ans += l2[l1.index(y)]

if x == 1 and y == 1:
    ans += 400000

print(ans)




# slower version:

N,i= map(int,input().split())                                                                                     

print (N-i+1)

# optimized version of the same code:

n, i = map(int, input().split())
print(n + 1 - i)





# slower version:

h, w = map(int, input().split())
for i in range(h):
    c = input()
    print(c)
    print(c)


# optimized version of the same code:

h, w = map(int, input().split())
a = [tuple(input()) for _ in range(h)]
for i in a:
    print(''.join(i))
    print(''.join(i))





# slower version:

import math

def cmb(n, r, mod):
    if ( r<0 or r>n ):
        return 0
    r = min(r, n-r)
    return g1[n] * g2[r] * g2[n-r] % mod

mod = 10**9+7 
N = 10**6
g1 = [1, 1] 
g2 = [1, 1] 
inverse = [0, 1] 

for i in range( 2, N + 1 ):
    g1.append( ( g1[-1] * i ) % mod )
    inverse.append( ( -inverse[mod % i] * (mod//i) ) % mod )
    g2.append( (g2[-1] * inverse[-1]) % mod )

X, Y = [int(i) for i in input().split()]

if (2*Y - X) % 3 != 0:
    print(0)
elif (2*X - Y) % 3 != 0:
    print(0)
else:
    x = (2*X - Y) // 3
    y = (2*Y - X) // 3
    print(cmb(x+y, x , mod))


# optimized version of the same code:

import math

def cmb(n, r, mod):
    r = min(r, n-r)

    a = 1
    b = 1
    for i in range(r):
        a = (a * (n-i)) % mod
        b = (b * (i+1)) % mod
    
    return a * pow(b, mod-2, mod) % mod

X, Y = [int(i) for i in input().split()]
mod = 10**9+7 
x_tmp = 2*X - Y
y_tmp = 2*Y - X

if x_tmp < 0 or y_tmp < 0:
    ans = 0
elif x_tmp % 3 != 0 or y_tmp % 3 != 0:
    ans = 0
else:
    x = x_tmp // 3
    y = y_tmp // 3
    ans = cmb(x + y, y, mod)

print(ans)




# slower version:

n,l=map(int, input().split())
s=[list(input()) for i in range(n)]
s.sort()
for i in s:
    for j in i:
        print(j,end='')
print()

# optimized version of the same code:

n, m = list(map(int, input().split()))

s = []

for i in range(n):
    s.append(input())

s.sort()

for i in range(n):
    print(s[i], end = '')




# slower version:

N, X = [int(i) for i in input().split()]
donut_type = [int(input()) for i in range(N)]
X = X - sum(donut_type)
result = N
while X >= sorted(donut_type)[0]:
    X = X - sorted(donut_type)[0]
    result += 1

print(result)

# optimized version of the same code:

import math
N, X = [int(i) for i in input().split()]
donut_type = [int(input()) for i in range(N)]
X = X - sum(donut_type)
result = N
result += math.floor(X / min(donut_type))

print(result)




# slower version:

n,m,k = map(int,input().split())

for i in range(m+1):
  for j in range(n+1):
    if n*i + m*j - 2*i*j == k:
      print('Yes')
      exit()
print('No')

# optimized version of the same code:

n,m,k = map(int,input().split())

for i in range(m+1):
    a = k - i * n
    b = m - 2 * i
    if b != 0 and a % b == 0 and 0 <= a // b <= n:
        print('Yes')
        exit()
print('No')




# slower version:

def main():
    n, x, y = map(int, input().split()) 

    ans = [0] * n
    for i in range(1,n):
        for j in range(i+1, n+1):
            r1 = j-i
            r2 = abs(x-i) + 1 + abs(j-y)
            r3 = abs(y-i) + 1 + abs(j-x)
            ans[min(r1,r2,r3)] += 1

    for i in range(1,n):
        print(ans[i])

if __name__ == '__main__':
    main()

# optimized version of the same code:

n,x,y = map(int, input().split())

ans = [0]*n
for i in range(1,n):
    for j in range(i+1,n+1):
        v1 = j-i
        v2 = abs(x-i) + 1 + abs(y-j)
        v3 = abs(y-i) + 1 + abs(x-j)
        minv = min(v1,v2,v3)
        ans[minv] += 1

for a in ans[1:]:
    print(a)




