# slower version:

scores = [list(map(int, input().split())) for _ in range(2)]
print(max(sum(scores[0]), sum(scores[1])))

# optimized version of the same code:

print(max(sum(map(int, input().split())), sum(map(int, input().split()))))




# slower version:

import math
#X=int(input())
N,M,Q=map(int,input().split())
S=[[]for i in range(Q)]
for i in range(Q):
    a=list(map(int,input().split()))
    S[i]=a
ans=0
T=0
for a in range(1,M+1):
    for b in range(a, M+1):
        for c in range(b, M+1):
            for d in range(c, M+1):
                for e in range(d, M+1):
                    for f in range(e, M+1):
                        for g in range(f, M+1):
                            for h in range(g, M+1):
                                for i in range(h, M+1):
                                    for j in range(i, M+1):
                                        D=[a,b,c,d,e,f,g,h,i,j]
                                        for k in range(Q):
                                            if D[S[k][1]-1]-D[S[k][0]-1]==S[k][2]:
                                                ans+=S[k][3]
                                        if ans>=T:
                                            T=ans
                                        ans = 0
print(T)


# optimized version of the same code:

import math
import sys
sys.setrecursionlimit(10**7)
#X=int(input())
N,M,Q=map(int,input().split())
S=[[]for i in range(Q)]
for i in range(Q):
    a=list(map(int,input().split()))
    S[i]=a
ans=0
T=0
def solve(l):
    global ans
    if len(l)>=N:
        tmp=0
        for k in range(Q):
            if l[S[k][1]-1]-l[S[k][0]-1]==S[k][2]:
                tmp+=S[k][3]
        ans=max(ans,tmp)
        return
    for i in range(l[-1],M+1):
        solve(l+[i])
solve([1])
print(ans)




# slower version:

import sys

N, M = map(int, sys.stdin.readline().split())
a_list = list(map(int, sys.stdin.readline().split()))
items = []
for i in range(M):
    items.append(tuple(map(int, sys.stdin.readline().split())))


from collections import defaultdict

tar = defaultdict(int)
for a in a_list:
    tar[a] += 1

for i in range(M):
    b, c = items[i]
    tar[c] += b

tar = sorted(tar.items(), key=lambda x: -x[0])

cnt = 0
ans = 0
for k, v in tar:
    if cnt + v <= N:
        cnt +=v
        ans += k*v
    else:
        ans += k*(N-cnt)
        cnt = N
    if cnt >= N:
        break
print(ans)


# optimized version of the same code:

import sys

N, M = map(int, sys.stdin.readline().split())
a_list = list(map(int, sys.stdin.readline().split()))
items = []
for i in range(M):
    items.append(tuple(map(int, sys.stdin.readline().split())))

from heapq import *

que = []

for i in range(N):
    a = a_list[i]
    heappush(que, (-a, 1))

for b, c in items:
    heappush(que, (-c, b))

cnt = 0
ans = 0
while cnt < N:
    k, v = heappop(que)
    if cnt + v <= N:
        cnt += v
        ans += -(k * v)
    else:
        ans += -(k) * (N-cnt)
        cnt = N
print(ans)





# slower version:

from collections import deque
n,*L=map(int,open(0).read().split())
G=[[]for _ in range(n)]
db=[-1]*n;db[0]=0
dw=[-1]*n;dw[-1]=0
for a,b in zip(*[iter(L)]*2):
	G[a-1]+=[b-1]
	G[b-1]+=[a-1]
q=deque([0])
while q:
	cur=q.popleft()
	for nxt in G[cur]:
		if db[nxt]<0:
			q.append(nxt)
			db[nxt]=db[cur]+1
q=deque([n-1])
while q:
	cur=q.popleft()
	for nxt in G[cur]:
		if dw[nxt]<0:
			q.append(nxt)
			dw[nxt]=dw[cur]+1
b=w=0
for i,j in zip(db,dw):
	if i<=j:b+=1
	else:w+=1
if b<=w:print('Snuke')
else:print('Fennec')

# optimized version of the same code:

from collections import*
n,*L=map(int,open(0).read().split())
G=[[]for _ in range(n)]
for a,b in zip(*[iter(L)]*2):
	G[a-1]+=[b-1]
	G[b-1]+=[a-1]
def F(m):
	q=deque([m])
	d=[-1]*n
	while q:
		cur=q.popleft()
		for nxt in G[cur]:
			if d[nxt]<0:
				q.append(nxt)
				d[nxt]=d[cur]+1
	return d
print('FSennunkeec'[sum(i>j or-1 for i,j in zip(F(0),F(n-1)))>=0::2])




# slower version:

n = int(input())
bt, bx, by = 0, 0, 0
ans = 'Yes'
for i in range(n):
    t, x, y = map(int, input().split())
    if ((t % 2 == 0 and (x + y) % 2 == 0) or (t % 2 == 1 and (x + y) % 2 == 1)) and (abs(x - bx) + abs(y - by) <= t - bt):
        bt, bx, by = t, x, y
        continue
    else:
        ans = 'No'
        break
print(ans)


# optimized version of the same code:

n = int(input())
ans = 'Yes'
for _ in range(n):
    t, x, y = map(int, input().split())
    if (t < x + y) or (t + x + y) % 2 == 1:
        ans = 'No'
print(ans)





# slower version:

N, M = map(int, input().split())
g = [[False]*N for _ in range(N)]
for _ in range(M):
	a, b = map(int, input().split())
	g[a-1][b-1] = True
	g[b-1][a-1] = True

stack = [[0,[1]+[0]*(N-1)]]
ans = 0
while stack:
	cur, passed = stack.pop()
	if passed == [1]*N:
		ans += 1
	else:
		for i, j in enumerate(g[cur]):
			if j and not passed[i]:
				t = passed.copy()
				t[i] = 1
				stack.append([i, t])
print(ans)

# optimized version of the same code:

N, M = map(int, input().split())
g = [[] for i in range(N)]
for i in range(M):
	a, b = map(int, input().split())
	g[a-1].append(b-1)
	g[b-1].append(a-1)

ans = 0
passed = [0]
n = 0
s = [[n,passed]]
while s:
	n, passed = s.pop()
	if len(passed) == N:
		ans += 1
	else:
		for i in g[n]:
			if i not in passed:
				s.append([i, passed + [i]])
print(ans)




# slower version:

n = int(input())
sum = 0
for num in range(1,n + 1):
    sum += num
print(sum)

# optimized version of the same code:

n = int(input())
print(sum(list(range(1,n+1))))




# slower version:

cnt500 = int(input())
cnt100 = int(input())
cnt50 = int(input())
X = int(input())

all = []
for a in range(cnt500+1):
    for b in range(cnt100+1):
        for c in range(cnt50+1):
            all.append(a*500 + b*100 + c*50)
print(all.count(X))

# optimized version of the same code:

cnt500 = int(input())
cnt100 = int(input())
cnt50 = int(input())
X = int(input())

result = 0
for a in range(cnt500+1):
    for b in range(cnt100+1):
        for c in range(cnt50+1):
           if (a*500 + b*100 + c*50) == X:
               result += 1
print(result)




