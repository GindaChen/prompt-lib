# slower version:

a, b, c = map(int, input().split())
if c-(a-b) <= 0:
    print(0)
else:
    print(c-(a-b))

# optimized version of the same code:

a, b, c = map(int, input().split())
print(max(0,c-(a-b)))




# slower version:

import itertools

N, M = map(int, input().split())
ab = []
for _ in range(M):
    a, b = map(int, input().split())
    ab.append({a-1, b-1})

ans = 0
for v in itertools.permutations(range(1, N)):
    ok = True
    a = 0
    for b in v:
        if {a, b} not in ab:
            ok = False
            break
        a = b
    if ok:
        ans += 1

print(ans)


# optimized version of the same code:

N, M = map(int, input().split())
ab = [[] for _ in range(N)]
for _ in range(M):
    a, b = map(int, input().split())
    ab[a-1].append(b-1)
    ab[b-1].append(a-1)

ans = 0
def dfs(x, visited):
    global ans
    if len(visited) == N:
        ans += 1
        return

    for b in ab[x]:
        if b not in visited:
            dfs(b, visited + [b])
    return

dfs(0, [0])
print(ans)





# slower version:

x,t = map(int,input().split())

if x < t:
    print(0)
else:
    print(x-t)

# optimized version of the same code:

x,t = map(int,input().split())
print(max(0,x-t))




# slower version:

n=int(input())
a=[int(input()) for _ in range(n)]

q=[]

def bisect_desc(a,x):
    r = len(a)
    if r == 0:
        return 0
    l = 0
    while l != r:
        f = (l+r)//2
        if a[f] >= x:
            l = f+1
        else:
            r = f
    return l

for sa in a:
    t = bisect_desc(q,sa)
    if t ==len(q):
        q.append(sa)
    else:
        q[t] = sa

print(len(q))

# optimized version of the same code:

n=int(input())
a=[int(input()) for _ in range(n)]

q=[]

def bisect_desc(a,x):
    r = len(a)
    if r == 0:
        return 0
    l = 0
    while l != r:
        f = (l+r)//2
        if a[f] >= x:
            l = f+1
        else:
            r = f
    return l

for sa in a:
    t = bisect_desc(q,sa)
    if t ==len(q):
        q.append(sa)
    else:
        q[t] = sa

print(len(q))





# slower version:

n=int(input())
p=[int(i) for i in input().split()]
for i in range(n):
    if i!=0:p[i]=min(p[i-1],p[i])
print(len(set(p)))


# optimized version of the same code:

n=int(input())
p=[int(i) for i in input().split()]
for i in range(1,n):p[i]=min(p[i-1],p[i])
print(len(set(p)))





# slower version:

import sys
input=sys.stdin.readline
from bisect import bisect_left,insort_left
d=int(input())
c=list(map(int,input().split()))
s=[list(map(int,input().split()))for _ in range(d)]
t=[int(input())for _ in range(d)]
m=int(input())
dq=[list(map(int,input().split()))for _ in range(m)]
x=[[0]for _ in range(26)]
ans=0
for i in range(d):
  v=t[i]-1
  ans+=s[i][v]-c[v]*(i-x[v][-1]+1)*(i-x[v][-1])//2
  x[v].append(i+1)
for i in range(26):
  ans-=c[i]*(d+1-x[i][-1])*(d-x[i][-1])//2
  x[i].append(d+1)
for dd,q in dq:
  p=t[dd-1]
  t[dd-1]=q
  ans-=s[dd-1][p-1]
  ans+=s[dd-1][q-1]
  pi=bisect_left(x[p-1],dd)
  qi=bisect_left(x[q-1],dd)
  pl=dd-x[p-1][pi-1]
  pr=x[p-1][pi+1]-dd
  ql=dd-x[q-1][qi-1]
  qr=x[q-1][qi]-dd
  del x[p-1][pi]
  x[q-1].insert(qi,dd)
  ans-=c[p-1]*pl*pr
  ans+=c[q-1]*ql*qr
  print(ans)

# optimized version of the same code:

import sys
input=sys.stdin.readline
from bisect import bisect_left,insort_left
d=int(input())
c=list(map(int,input().split()))
s=[list(map(int,input().split()))for _ in range(d)]
t=[int(input())for _ in range(d)]
m=int(input())
dq=[list(map(int,input().split()))for _ in range(m)]
x=[[0]for _ in range(26)]
ans=0
for i in range(d):
  v=t[i]-1
  ans+=s[i][v]-c[v]*(i-x[v][-1]+1)*(i-x[v][-1])//2
  x[v].append(i+1)
for i in range(26):
  ans-=c[i]*(d+1-x[i][-1])*(d-x[i][-1])//2
  x[i].append(d+1)
for dd,q in dq:
  p=t[dd-1]
  t[dd-1]=q
  ans-=s[dd-1][p-1]
  ans+=s[dd-1][q-1]
  pi=bisect_left(x[p-1],dd)
  qi=bisect_left(x[q-1],dd)
  pl=dd-x[p-1][pi-1]
  pr=x[p-1][pi+1]-dd
  ql=dd-x[q-1][qi-1]
  qr=x[q-1][qi]-dd
  del x[p-1][pi]
  x[q-1].insert(qi,dd)
  ans-=c[p-1]*pl*pr
  ans+=c[q-1]*ql*qr
  print(ans)





# slower version:

n,m=map(int,input().split())
li=[]
for i in range(m):
    a=list(map(int,input().split()))
    li.append(a)
l=0
r=n
for i in range(m):
    if li[i][0]>l:
        l=li[i][0]
    if li[i][1]<r:
        r=li[i][1]
print(max(0,r-l+1))
    

# optimized version of the same code:

n,m=map(int,input().split())
L=[]
R=[]
for i in range(m):
    l,r=map(int,input().split())
    L.append(l)
    R.append(r)
a=max(L)
b=min(R)
li=[i for i in range(a,b+1)]
print(len(li))






# slower version:

n = int(input())
d = list(map(int, input().split()))
mod = 998244353

a = [0] * n
for d_ in d:
    a[d_] += 1

res = d[0] == 0 and a[0] == 1
pre = 1
for a_ in a:
    res *= pre ** a_
    res %= mod
    pre = a_

print(res)

# optimized version of the same code:

n = int(input())
d = list(map(int, input().split()))
mod = 998244353

a = [0] * n
for d_ in d:
    a[d_] += 1

res = d[0] == 0 and a[0] == 1
pre = 1
for a_ in a:
    res = res * pre ** a_ % mod
    pre = a_

print(res)




